'use strict';

var postcss = require('postcss');

var affectedProps = require('./affected-props');

var _require = require('./options'),
    validateOptions = _require.validateOptions;

var _require2 = require('./keyframes'),
    isKeyframeRule = _require2.isKeyframeRule,
    isKeyframeAlreadyProcessed = _require2.isKeyframeAlreadyProcessed,
    isKeyframeSymmetric = _require2.isKeyframeSymmetric,
    rtlifyKeyframe = _require2.rtlifyKeyframe;

var _require3 = require('./rules'),
    getDirRule = _require3.getDirRule,
    processSrcRule = _require3.processSrcRule;

var _require4 = require('./decls'),
    rtlifyDecl = _require4.rtlifyDecl,
    ltrifyDecl = _require4.ltrifyDecl;

var _require5 = require('./selectors'),
    isSelectorHasDir = _require5.isSelectorHasDir;

module.exports = postcss.plugin('postcss-rtl', function (options) {
  return function (css) {

    var keyframes = [];

    options = validateOptions(options);

    var handleIgnores = function handleIgnores() {
      var removeComments = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      var isIgnored = false;
      var continuousIgnore = false;

      return function (node) {
        if (node.type === 'comment') {
          switch (node.text) {
            case 'rtl:ignore':
              isIgnored = true;
              continuousIgnore = continuousIgnore || false;
              removeComments && node.remove();
              break;
            case 'rtl:begin:ignore':
              isIgnored = true;
              continuousIgnore = true;
              removeComments && node.remove();
              break;
            case 'rtl:end:ignore':
              isIgnored = false;
              continuousIgnore = false;
              removeComments && node.remove();
              break;
          }
          return true;
        }
        if (!continuousIgnore && isIgnored) {
          isIgnored = false;
          return true;
        }
        return isIgnored;
      };
    };

    var isKeyframeIgnored = handleIgnores();
    var isRuleIgnored = handleIgnores(true);
    var valueIgnoreDirective = /\/\*\s*rtl\s*:\s*ignore\s*\*\/$/;

    // collect @keyframes
    css.walk(function (rule) {

      if (isKeyframeIgnored(rule)) return;
      if (rule.type !== 'atrule') return;

      if (!isKeyframeRule(rule)) return;
      if (isKeyframeAlreadyProcessed(rule)) return;
      if (isKeyframeSymmetric(rule)) return;

      keyframes.push(rule.params);
      rtlifyKeyframe(rule, options);
    });

    // Simple rules (includes rules inside @media-queries)
    css.walk(function (node) {
      var ltrDecls = [];
      var rtlDecls = [];
      var dirDecls = [];

      if (isRuleIgnored(node)) return;

      if (node.type !== 'rule') {
        return;
      }
      var rule = node;

      if (isSelectorHasDir(rule.selector, options)) return;
      if (isKeyframeRule(rule.parent)) return;

      rule.walkDecls(function (decl) {
        var rawValue = decl.raws.value;
        var value = rawValue && rawValue.raw;

        // Does the raw value contain a rtl:ignore comment?
        if (value && value.match(valueIgnoreDirective)) {
          // Skip this directive.
          return;
        }

        var rtl = rtlifyDecl(decl, keyframes);

        if (rtl) {
          ltrDecls.push(ltrifyDecl(decl, keyframes));
          rtlDecls.push(decl.clone(rtl));
          return;
        }

        if (affectedProps.indexOf(decl.prop) >= 0) {
          dirDecls.push(decl);
          decl.remove();
        }
      });

      if (rtlDecls.length) {
        if (!options.onlyDirection || options.onlyDirection === 'rtl') {
          getDirRule(rule, 'rtl', options).append(rtlDecls);
        }

        var ltrDirRule = getDirRule(rule, 'ltr', options);
        ltrDecls.forEach(function (_decl) {
          _decl.cleanRaws(_decl.root() === ltrDirRule.root());
          rule.removeChild(_decl);
          if (!options.onlyDirection || options.onlyDirection === 'ltr') {
            ltrDirRule.append(_decl);
          }
        });

        if (options.onlyDirection && options.onlyDirection === 'rtl') {
          ltrDirRule.remove();
        }
      }

      if (dirDecls.length) {
        getDirRule(rule, 'dir', options).append(dirDecls);
      }

      /* set dir attrs */
      processSrcRule(rule, options);
    });
    return false;
  };
});